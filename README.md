# Основное содержание

## Выделение

``` sql
SELECT * FROM products WHERE price < 3000;
```

``` sql
SELECT * FROM orders WHERE status in ('cancelled', 'new');
```

## Операторы OR и AND

``` sql
SELECT * FROM orders WHERE sum > 3000 OR products_count >=3:
```

**Оператор OR, в отличие от AND, объединяет два условия**

**У AND приоритет выполнения выше**

``` sql
SELECT * FROM orders WHERE sum BETWEEN 3000 AND 10000 OR status = 'cancelled';
```

``` sql
SELECT * FROM orders WHERE products_count=2 OR products_count=5 AND status = 'cancelled';
```

``` sql
SELECT * FROM orders WHERE (products_count=2 OR products_count=5) AND status = 'cancelled';
```

**Скобки используются для изменения приоритета операторов**

``` sql
SELECT * FROM orders WHERE status = 'cancelled' AND (sum < 3000 or sum > 10000);
```

``` sql
SELECT name, price FROM products ORDER BY price DESC;
```

``` sql
SELECT * FROM products WHERE price >=5000 ORDER BY price DESC;
```

## Сортировка

``` sql
SELECT name, count, price FROM products WHERE price <= 3000 ORDER BY name;
```

``` sql
SELECT name, count, price FROM products WHERE price <= 3000 ORDER BY name ASC;
```

``` sql
SELECT name, count, price FROM products WHERE price <= 3000 ORDER BY name DESC;
```

**ASC - сортировка по возрастанию (по умолчанию)**

**DESC - сортировка по убыванию**

``` sql
SELECT name, price FROM products WHERE count>0
ORDER BY name LIMIT 6 OFFSET 12;
```

**LIMIT - ограничение количества строк(в данном случае первые 6)**

**OFFSET - смещение, указывает на то, сколько записей нужно пропустить(в данном случае первые 12)**

## Добавление

**Добавление с помощью VALUES:**

``` sql
INSERT INTO orders (id, products, sum) VALUES (6, 3, 3000)
```

``` sql
INSERT INTO products (id, name, count, price) VALUE (8, 'iMac 21', 0, 100100)
```

**Можно использовать как VALUE, так и VALUES**

**Добавление с помощью SET:**

``` sql
INSERT INTO table (field1, field2) VALUES (value1, value2);
```

``` sql
INSERT INTO table SET field1=value1, field2=value2;
```

**Разница между VALUES и SET**

``` sql
INSERT INTO users SET id=10, first_name='Никита', last_name='Петров'
```

**Пакетный режим:**

``` sql
INSERT INTO table (field1, field2)  
VALUES  
    (value1_1, value1_2), 
    (value2_1, value2_2), 
    (value3_1, value3_2);
```

## Обновление/Замена

``` sql
UPDATE users SET salary=salary*1.1 WHERE salary<20000
```

**Умножение на 1.1, значит увеличение на 10%**

``` sql
UPDATE products SET name='iMac' WHERE name = 'IMAC'
```

**NULL – это особое слово в MySQL и в отличии от "cancelled" или "new", его нужно писать без кавычек. 
А чтобы сравнить значение в поле с NULL, нужно использовать не символы равенства (=) и неравенства (<>), 
а специальное выражение IS NULL или IS NOT NULL.**

**NULL нельзя сравнивать ни с чем!**

``` sql
UPDATE orders SET status='new' WHERE status IS NULL
```

``` sql
UPDATE orders SET amount=sum*products_count WHERE amount=0 OR amount IS NULL
```

``` sql
UPDATE products SET price=price*1.05 ORDER BY price desc limit 5
```

**Умножение на 1.05, значит увеличение на 5%**

## Удаление

``` sql
DELETE FROM products WHERE count<1;
```

**Удаление всех строк в таблице:**

``` sql
DELETE FROM users;
```

``` sql
TRUNCATE table users;
```

## Создание таблицы

``` sql
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
   ....
);
```

**Например:**

``` sql
CREATE TABLE orders (
    id INT UNSIGNED NOT NULL PRIMARY KEY,
    user_id INTEGER NULL,
    products_count INTEGER NULL,
    sum INTEGER NULL,
    status VARCHAR(20) NULL
);
```

## Удаление таблицы

``` sql
DROP TABLE table_name;
```

## Типы данных

**Символьные типы**

- **CHAR**: представляет строку фиксированной длины.

    Длина хранимой строки указывается в скобках, например, CHAR(10) - строка из десяти символов. И если в таблицу в данный столбец сохраняется строка из 6 символов (то есть меньше установленной длины в 10 символов), то строка дополняется 4 пробелами и в итоге все равно будет занимать 10 символов

    Тип CHAR может хранить до 255 байт.

- **VARCHAR**: представляет строку переменной длины.

    Длина хранимой строки также указыватся в скобках, например, VARCHAR(10). Однако в отличие от CHAR хранимая строка будет занимать именно столько места, сколько необходимо. Например, если определенная длина в 10 символов, но в столбец сохраняется строка в 6 символов, то хранимая строка так и будет занимать 6 символов плюс дополнительный байт, который хранит длину строки.

    Всего тип VARCHAR может хранить до 65535 байт.

Начиная с MySQL 5.6 типы CHAR и VARCHAR по умолчанию используют кодировку UTF-8, которая позволяет использовать до 3 байт для хранения символа в зависимости от языка ( для многих европейских языков по 1 байту на символ, для ряда восточно-европейских и ближневосточных - 2 байта, а для китайского, японского, корейского - по 3 байта на символ).

Ряд дополнительных типов данных представляют текст неопределенной длины:

- **TINYTEXT**: представляет текст длиной до 255 байт.

- **TEXT**: представляет текст длиной до 65 КБ.

- **MEDIUMTEXT**: представляет текст длиной до 16 МБ

- **LONGTEXT**: представляет текст длиной до 4 ГБ

**Числовые типы**

- **TINYINT**: представляет целые числа от -128 до 127, занимает 1 байт

- **BOOL**: фактически не представляет отдельный тип, а является лишь псевдонимом для типа TINYINT(1) и может хранить два значения 0 и 1. Однако данный тип может также в качестве значения принимать встроенные константы TRUE (представляет число 1) и FALSE (предоставляет число 0).

    Также имеет псевдоним **BOOLEAN**.

- **TINYINT UNSIGNED**: представляет целые числа от 0 до 255, занимает 1 байт

- **SMALLINT**: представляет целые числа от -32768 до 32767, занимает 2 байтa

- **SMALLINT UNSIGNED**: представляет целые числа от 0 до 65535, занимает 2 байтa

- **MEDIUMINT**: представляет целые числа от -8388608 до 8388607, занимает 3 байта

- **MEDIUMINT UNSIGNED**: представляет целые числа от 0 до 16777215, занимает 3 байта

- **INT**: представляет целые числа от -2147483648 до 2147483647, занимает 4 байта

- **INT UNSIGNED**: представляет целые числа от 0 до 4294967295, занимает 4 байта

- **BIGINT**: представляет целые числа от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807, занимает 8 байт

- **BIGINT UNSIGNED**: представляет целые числа от 0 до 18 446 744 073 709 551 615, занимает 8 байт

- **DECIMAL**: хранит числа с фиксированной точностью. Данный тип может принимать два параметра precision и scale: DECIMAL(precision, scale).

    Параметр precision представляет максимальное количество цифр, которые может хранить число. Это значение должно находиться в диапазоне от 1 до 65.

    Параметр scale представляет максимальное количество цифр, которые может содержать число после запятой. Это значение должно находиться в диапазоне от 0 до значения параметра precision. По умолчанию оно равно 0.

    Например, в определении следующего столбца:

    ``` sql
    salary DECIMAL(5,2)
    ```

    Число 5 - precision, а число 2 - scale, поэтому данный столбец может хранить значения из диапазона от -999.99 до 999.99.

    Размер данных в байтах для DECIMAL зависит от хранимого значения.
  
    Данный тип также имеет псевдонимы **NUMERIC**, **DEC**, **FIXED**.

- **FLOAT**: хранит дробные числа с плавающей точкой одинарной точности от -3.4028 * 10^38 до 3.4028 * 10^38, занимает 4 байта

    Может принимать форму FLOAT(M,D), где M - общее количество цифр, а D - количество цифр после запятой.

- **DOUBLE**: хранит дробные числа с плавающей точкой двойной точности от -1.7976 * 10^308 до 1.7976 * 10^308, занимает 8 байт. Также может принимать форму DOUBLE(M,D), где M - общее количество цифр, а D - количество цифр после запятой.

    Данный тип также имеет псевдонимы **REAL** и **DOUBLE PRECISION**, которые можно использовать вместо DOUBLE.

**Типы для работы с датой и временем**

- **DATE**: хранит даты с 1 января 1000 года до 31 деабря 9999 года (c "1000-01-01" до "9999-12-31"). По умолчанию для хранения используется формат yyyy-mm-dd. Занимает 3 байта.

- **TIME**: хранит время от -838:59:59 до 838:59:59. По умолчанию для хранения времени применяется формат "hh:mm:ss". Занимает 3 байта.

- **DATETIME**: объединяет время и дату, диапазон дат и времени - с 1 января 1000 года по 31 декабря 9999 года (с "1000-01-01 00:00:00" до "9999-12-31 23:59:59"). Для хранения по умолчанию используется формат "yyyy-mm-dd hh:mm:ss". Занимает 8 байт

- **TIMESTAMP**: также хранит дату и время, но в другом диапазоне: от "1970-01-01 00:00:01" UTC до "2038-01-19 03:14:07" UTC. Занимает 4 байта

- **YEAR**: хранит год в виде 4 цифр. Диапазон доступных значений от 1901 до 2155. Занимает 1 байт.

Тип Date может принимать даты в различных форматах, однако непосредственно для хранения в самой бд даты приводятся к формату "yyyy-mm-dd". Некоторые из принимаемых форматов:

- yyyy-mm-dd - 2018-05-25

- yyyy-m-dd - 2018-5-25

- yy-m-dd - 18-05-25

    В таком формате двузначные числа от 00 до 69 воспринимаются как даты в диапазоне 2000-2069. А числа от 70 до 99 как диапазон чисел 1970 - 1999.

- yyyymmdd - 20180525

- yyyy.mm.dd - 2018.05.25

Для времени тип Time использует 24-часовой формат. Он может принимать время в различных форматах:

- hh:mi - 3:21 (хранимое значение 03:21:00)

- hh:mi:ss - 19:21:34

- hhmiss - 192134

Примеры значений для типов DATETIME и TIMESTAMP:

- 2018-05-25 19:21:34

- 2018-05-25 (хранимое значение 2018-05-25 00:00:00)

**Составные типы**

- **ENUM**: хранит одно значение из списка допустимых значений. Занимает 1-2 байта

- **SET**: может хранить несколько значений (до 64 значений) из некоторого списка допустимых значений. Занимает 1-8 байт.

**Бинарные типы**
- **TINYBLOB**: хранит бинарные данные в виде строки длиной до 255 байт.

- **BLOB**: хранит бинарные данные в виде строки длиной до 65 КБ.

- **MEDIUMBLOB**: хранит бинарные данные в виде строки длиной до 16 МБ

- **LONGBLOB**: хранит бинарные данные в виде строки длиной до 4 ГБ

**Значения числовых типов**

[EN]

| Type      | Storage (Bytes) | Minimum Value Signed | Minimum Value Unsigned | Maximum Value Signed | Maximum Value Unsigned |
| --------- | --------------- | -------------------- | ---------------------- | -------------------- | ---------------------- |
| TINYINT   | 1               | -128                 | 0                      | 127                  | 255                    |
| SMALLINT  | 2               | -32768               | 0                      | 32767                | 65535                  |
| MEDIUMINT | 3               | -8388608             | 0                      | 8388607              | 16777215               |
| INT       | 4               | -2147483648          | 0                      | 2147483647           | 4294967295             |
| BIGINT    | 8               | -2^63                | 0                      | -2^63 - 1            | -2^64 - 1              |

[RU]

| Тип       | Размер (Байты) | Минимальное значение со знаком | Минимальное значение без знака | Максимальное значение со знаком | Максимальное значение без знака |
| --------- | -------------- | ------------------------------ | ------------------------------ | ------------------------------- | ------------------------------- |
| TINYINT   | 1              | -128                           | 0                              | 127                             | 255                             |
| SMALLINT  | 2              | -32768                         | 0                              | 32767                           | 65535                           |
| MEDIUMINT | 3              | -8388608                       | 0                              | 8388607                         | 16777215                        |
| INT       | 4              | -2147483648                    | 0                              | 2147483647                      | 4294967295                      |
| BIGINT    | 8              | -2^63                          | 0                              | -2^63 - 1                       | -2^64 - 1                       |

##  Кавычки и перенос строк

``` sql
'\'Давыдов\' \n
```

``` sql
\'Алекс\''
```

## Cтроковые типы со значениями которые выбираются из фиксированного списка значений

**ENUM**

``` sql
state ENUM('draft', 'correction', 'public')
```

**SET**

``` sql
additional SET('conditioner','bar','fridge','wifi')
```

**Когда можно выбрать 1 вариант - используем ENUM**

**Когда можно выбрать несколько вариантов - используем SET**

## Уникальные строки/Исключение дубликатов

Удаление повторяющихся строк запроса и оставлять только уникальные:

``` sql
SELECT DISTINCT class FROM Student_in_class;
```

``` sql
SELECT DISTINCT Country FROM Customers;
```

Если в запрос добавить ещё одно поле, то эту выборку попадут строки с уникальным сочетанием курса и слушателя:

``` sql
SELECT DISTINCT
    course_id,
    user_id
FROM course_members ORDER BY course_id;
```

Есть модификация этого оператора — DISTINCT ON. Такой вариант оператора позволяет указать:

- Поле, которое должно быть уникальным.

- Поля, которые нужно вывести.

Так выглядит запрос с DISTINCT ON:

``` sql
SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at;
```

Сортировка с оператором DISTINCT ON

При работе с DISTINCT ON важно правильно использовать сортировку. Первыми полями в ORDER BY должны быть те, которые идут после DISTINCT ON.

Для примера напишем еще один запрос — к каждому уникальному курсу выведем дату, в которую записался последний студент.

Для этого нужно после ORDER BY сначала указать поле course_id, как того требует синтаксис. Затем нужно добавить поле created_at с сортировкой по убыванию:

``` sql
SELECT DISTINCT ON (course_id)
    course_id,
    created_at
FROM course_members
ORDER BY course_id, created_at DESC;
```

Этот запрос выведет все уникальные курсы и дату, когда на этот курс в последний раз записывались.

## Фильтрация строк после группировки (Having)

Иногда встречаются задачи, в которых требуется отфильтровать записи после группировки.

Для примера представим, что нам нужно вывести суммарное время, проведенное на платформе каждым пользователем:

``` sql
SELECT
  user_id,
  SUM(spent_minutes)
FROM course_reviews
GROUP BY user_id
ORDER BY user_id;
```

Давайте доработаем этот запрос таким образом, чтобы в итоговой выборке отображались только те группы, чья средняя стоимость больше 50.

Обладая предыдущим опытом, есть большой соблазн попытаться использовать для этих целей оператор WHERE. Но при попытке выполнить такой запрос СУБД неминуемо выдаст ошибку, указав, что мы некорректно используем синтаксис WHERE avg_price > 50.

``` sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
WHERE avg_price > 50
```

## Объединение строки из двух или более таблиц на основе связующего столбца между ними (Join)

**SQL Inner Join**

Этот режим объединения результатов поиска в базах данных SQL включается автоматически. Если вы не укажете намеренно тип Join, то сработает именно Inner Join. С помощью него можно указать сразу два критерия (две таблицы) и по ним отсеять контент. 

Достаточно прописать SQL-запрос в духе:

``` sql
SELECT *
FROM table-1
JOIN table-2 ON table-1.parameter=table-2.parameter
WHERE table-1.parameter IS ‘myData’
```

Фактически мы пытаемся выудить данные из первой таблицы и объединить их с данными из второй таблицы, при этом фильтруя только те записи, в которых совпадает значение параметра. В первой таблице оно приравнивается к myData.

На практике это может использоваться на сайте с музыкальными инструментами, например. Можно запрашивать гитары конкретного бренда, при этом еще и выбирая дополнительное условие в духе количества струн.

``` sql
SELECT *
FROM SevenStringGuitars
JOIN Ibanez ON SevenStringGuitar.brandId=Ibanez.brandId
```

Таким SQL-запросом мы можем отфильтровать все инструменты бренда Ibanez в категории «Гитары» с 7 струнами. 

**SQL Self Join**

Запросы Self Join полезны в тех случаях, когда необходимо выполнить фильтрацию контента внутри одной таблицы. Например, у вас есть список товаров в базе данных. У каждого из них указан свой бренд, но есть и те, что поставляются одним производителем. Self Join можно использовать для объединения двух стеков информации из одной таблицы. 

Например, можно запросить информацию о наименовании товара и параллельно обратиться к базе с названием бренда. Результатом работы функции станет появление нового списка товаров, соответствующего критериям.

SQL-команда в этом случае может выглядеть следующим образом:

``` sql
SELECT *
FROM products JOIN products ON table.product=table.brand
```

Такой сценарий полезен практически в любом виде баз данных, так как в одной таблице нередко может храниться информация о товарах или контенте, имеющим большое количество общих параметров. 

**SQL Cross Join**

Самый специфичный вариант фильтрации данных. Он подразумевает сбор сразу всех комбинаций элементов из нескольких таблиц, без обращения к какой-либо дополнительной информации (не требуется указывать id или любую другую строку в таблице).

Стандартный SQL-запрос с Cross Join может выглядеть следующим образом:

``` sql
SELECT *
FROM table-1
CROSS JOIN table-2
```

Этого достаточно, чтобы создать новый список элементов, в котором будут собраны все строки из базы данных, отфильтрованные только по выбранным таблицам. 

Полученный набор данных называют декартовым произведением. Схематично его часто изображают как большое количество перекрестий между двумя группами элементов. 

Такой вид JOIN применяется в онлайн-магазинах для вывода всех возможных пар по выбранным характеристикам одежды (цвету и размеру или другим параметрам).

**SQL Outer Join**

Outer Join – это своего рода противоположность Inner Join. Как понятно из названия, Outer Join предоставляет информацию не только из внутренней части поиска, но и из внешней. То есть программа ищет не только точечные совпадения по выбранным ранее критериям, а позволяет немного ослабить «хватку» и предоставить более «свободные» результаты поиска, включающие в себя элементы из таблиц, которые хоть и совпадают с критериями в SQL-запросе, но не полностью. 

Когда такой подход может понадобиться? Например, для скрупулезной фильтрации товаров. Если вы готовы покупать продукцию компании «Шестерочка» и не против, если среди нее окажется молоко, но при этом вы точно не хотите покупать молоко других производителей, то вам подойдет подобный фильтр. Он позволяет дать одному из критериев поиска что-то в духе привилегий.

**Разновидности Outer Join**

Внешние Join-запросы существуют не в единственном виде, а сразу в трех вариациях. Каждый вариант по-своему обрабатывает информацию и в итоге выдает разные результаты.

**Left**

Левое объединение подразумевает как раз выше описанный сценарий. Когда мы берем одну таблицу, подключаем вторую и при этом показываем не только точные совпадения, но еще и весь список строк, полученных из левой таблицы, для которых не нашлось пары в правой таблице.

На практике это может выглядеть так:

``` sql
SELECT *
FROM table1
LEFT JOIN table2 ON table1.parameter=table2.parameter
```

Теперь мы объединяем первую и вторую таблицу, доставая информацию как о совпадениях по заданным параметрам, так и по контенту без пары в левой таблице. 

При желании, надстраивая подобный фильтр, можно вовсе исключить целую категорию строк:

``` sql
SELECT * 
FROM table1
LEFT JOIN table2 ON table1.parameter=table2.parameter
WHERE table2.parameter IS NULL
```

На живом примере фильтрация такого рода может выглядеть так:

``` sql
SELECT *
FROM Russian
LEFT JOIN Rap ON Russian.genreId=Rap.genreId
```

Представим, что мы запустили продвинутый поиск на сайте с музыкальными альбомами. Мы хотим послушать что-то на русском языке. Причем готовы даже оценить качество отечественного рэпа. При этом в целом мы рэп не любим и не хотим, чтобы он попадался на каких-то других языках.

**Right**

Понятно, что правое объединение будет работать в обратную сторону и покажет элементы из правой таблицы, для которых не нашлось пары в левой. 

Получится следующий SQL-запрос:

``` sql
SELECT *
FROM table1
RIGHT JOIN table2 ON table1.parameter=table2.parameter
```

Если взять пример из предыдущей главы, то в реальности можно обернуть ситуацию в противоположную сторону. Искать только рэп-музыку, исключив все русское, кроме хип-хопа. Получится что-то в духе:

``` sql
SELECT *
FROM Russian
RIGHT JOIN Rap ON Russian.genreId=Rap.genreId
```

**Full**

Это вариант для тех, кто хочет использовать сразу два разных критерия для поиска какого-либо контента. Снова вернемся к примеру с музыкальным приложением. Join Full может пригодиться, если вы хотите послушать либо что-то на русском, либо любой рэп. Вам не важны какие-либо другие параметры. Вас волнуют исключительно две характеристики. При этом вам не так важно, будут ли они пересекаться. То есть вам все равно, будет рэп на русском или же на русском будет какой-то агрессивный металл.

SQL-запрос с таким Join мог бы выглядеть следующим образом:

``` sql
SELECT *
FROM table1
FULL OUTER JOIN table2 ON table1.parameter=table2.parameter
```

Можно исключить из результатов фильтрации все пары. То есть можно выбрать только рэп, но ни в коем случае не русский, и русскую музыку, но ни в коем случае не рэп (вполне могу понять такой выбор, кстати говоря). 

Чтобы это сделать, необходимо написать следующий SQL-запрос. 

``` sql
SELECT *
FROM Russian
FULL OUTER JOIN Rap ON Russian.genreId=Rap.genreId
WHERE Russian.genreId IS NULL OR Rap.genreId IS NULL
```

Теперь вы увидите в результатах поиска только непарные строки. 

## primary key и primary key auto_increment

Первичный ключ (PRIMARY KEY) - это одному или нескольким столбцам таблицы, которые используются для уникальной идентификации каждой строки 

``` sql
CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
); 
```

Автогенерацию первичного ключа часто называют автоинкрементом (autoincrement). Что переводится как автоматическое увеличение и напоминает операцию инкремента из программирования 

``` sql
CREATE TABLE example_table (
   id INTEGER PRIMARY KEY AUTOINCREMENT,
   name VARCHAR(50),
   age INT
);
```

# Примеры заданий

[06.02.2025]

**Задание:**

Из таблицы orders выбрать все заказы, где кол-во товара 2 или 5 и статус отменено

**Ответ:**

``` sql
select * from orders where products_count=2 or products_count=5 and status='cancelled';
```

**Задание:**

Выберите из таблицы orders все отмененные заказы исключая заказы стоимостью от 3000 до 10000 рублей включительно.

**Ответ:**

``` sql
select * from orders where status = 'cancelled' and (sum < 3000 or sum > 10000);
```

**Задание:**

Выберите из таблицы products все товары

**Ответ:**

``` sql
select * from products;
```

**Задание:**

Выберите из таблицы products все товары в порядке возрастания цены

**Ответ:**

``` sql
select name, price from products order by price DESC;
```

**Задание:**

Выберите из таблицы products все товары. 
Выведите только имена (name) и цены (price).

**Ответ:**

``` sql
select name, price from products order by price;
```

**Задание:**

Выберите из таблицы products все товары стоимостью 5000 и выше в порядке убывания цены (price).

**Ответ:**

``` sql
select * from products where price>=5000 order by price DESC;
```

**Задание:**

Выберите из таблицы products все товары стоимостью до 3000 рублей отсортированные в алфавитном порядке. Вывести нужно только имя (name), количество (count) и цену (price).

**Ответ:**

``` sql
select name, count, price from products where price<3000 order by name;
```

**Задание:**

Выберите из таблицы users фамилии (last_name) и имена (first_name) всех пользователей. 
Данные должны быть отсортированы сначала по фамилии, а затем по имени.

**Ответ:**

``` sql
select last_name, first_name from users order by last_name, first_name;
```

**Задание:**

Выберите из таблицы users всех пользователей с зарплатой от 40 000 рублей и выше. Данные нужно сначала отсортировать по убыванию зарплаты (salary), а затем в алфавитном порядке по имени (first_name).

**Ответ:**

``` sql
select * from users
where salary>=40000
order by salary DESK, first_name;
```

**Задание:**

Выберите сотрудников из таблицы users с зарплатой (salary) меньше 30 000 рублей и отсортируйте данные по дате рождения (birthday). Сотрудников с нулевой зарплатой выбирать не нужно.

**Ответ:**

``` sql
select * from users where salary<30000 and salary>0 order by birthday;
```

**Задание:**

Выберите из таблицы orders 5 самых дорогих заказов за всё время. 
Данные нужно отсортировать в порядке убывания цены. 
Отмененные заказы не учитывайте.

**Ответ:**

``` sql
select * from orders where status in('new', 'in_progress', 'delivery') 
order by sum desc limit 5;
```

**Задание:**

Выберите из таблицы products название и цены трех самых дешевых товаров, которые есть на складе.

**Ответ:**

``` sql
select name, price from products where count>0
order by price limit 3;
```

**Задание:**

Выберите из таблицы orders три последних заказа (по дате date) стоимостью от 3000 рублей и выше. 
Данные отсортируйте по дате в обратном порядке.

**Ответ:**

``` sql
select * from orders where sum>=3000 
order by date DESC limit 3;
```

**Задание:**

Сайт выводит товары по 5 штук. Выберите из таблицы products товары, которые пользователи увидят на 3 странице каталога при сортировке в порядке возрастания цены (price).

**Ответ:**

``` sql
select * from products order by price limit 5
```

**Задание:**

В таблице products 17 записей. Сайт выводит название (name) и цену (price) товаров в алфавитном порядке, по 6 записей на страницу. Напишите SQL запрос для получения списка товаров для формирования последней страницы каталога. 
Товары, которых нет на складе, выводить не надо (таких товаров 2).

**Ответ:**

``` sql
select name, price from products where count>0
order by name limit 6 offset 12;
```

[11.02.2025]

**Задание:**

Добавьте в таблицу orders данные о новом заказе стоимостью 3000 рублей. В заказе 3 товара (products).

**Ответ:**

``` sql
INSERT INTO orders (id, products, sum) VALUES (6, 3, 3000)
```

**Задание:**

Добавьте в таблицу products новый товар — «Xbox», стоимостью 30000 рублей в количестве (count) трех штук

**Ответ:**

``` sql
INSERT INTO products (id, name, count, price) VALUES (7, 'Xbox', 3, 30000)
```

**Задание:**

Добавьте в таблицу products новый товар — «iMac 21», стоимостью 100100 рублей.

Товар пока не завезли на склад.

**Ответ:**

``` sql
insert into products (id, name, count, price) value (8, 'iMac 21', 0, 100100)
```

**Задание:**

Добавьте в таблицу users нового пользователя Антона Пепеляева с датой рождения 12 июля 1992 года

**Ответ:**

``` sql
insert into users (id, first_name, last_name, birthday) value (9, 'Антон', 'Пепеляев', '1992-07-12')
```

**Задание:**

Добавьте в таблицу users нового пользователя Никиту Петрова. Дату рождения не указывайте. 

Используйте ключевое слово SET.

**Ответ:**

``` sql
insert into users SET id=10, first_name='Никита', last_name='Петров'
```

**Задание:**

Добавьте одним SQL запросом в таблицу products следующие товары: 

* iPhone 7, цена 59990, 1 шт.

* iPhone 8, цена 64990, 3 шт.

* iPhone X, цена 79900, 2 шт.

**Ответ:**

``` sql

```

**Задание:**

В таблицу products внесли данные с ошибкой, вместо iMac в наименовании написали IMAC. Исправьте ошибку.

**Ответ:**

``` sql
update products set name='iMac' where name = 'IMAC'
```

**Задание:**

Увеличьте в таблице users сотрудникам, у которых зарплата менее 20 000 рублей, зарплату (salary) на 10%.

**Ответ:**

``` sql
update users set salary=salary*1.1 where salary<20000
```

**Задание:**

Проставьте всем заказам без статуса (status равен NULL) статус "new".

**Ответ:**

``` sql
update orders set status='new' where status is NULL
```

**Задание:**

В поле amount в таблице orders должно стоять число, которое равно произведению цены (sum) на количество (products_count). Но из-за сбоя в системе некоторые значения суммы получили 0 или NULL. Обновите таблицу, чтобы в поле amount были правильные значения.

**Ответ:**

update orders set amount=sum*products_count where amount=0 or amount is NULL

[12.04.2025]

пример использования default при объявлении переменной:

``` sql
amount mediumint(8) UNSIGNED not null default 0
```

Пример default в enum:

``` sql
state enum ('new','cancelled','in_progress','delivered','completed') not null default 'new');
```

пример вызова под VALUES в insert into table:

``` sql
(1,56,5400,'2018-02-01 17:46:59', default),
```

[22.04.2025]

**Задание:**

Создайте таблицу users с со следующими полями:

id — идентификатор, целое положительное, первичный ключ без автоинкремента, NULL запрещен.
first_name — имя пользователя, строка до 50 символов.
last_name — фамилия пользователя, строка до 50 символов.
birthday — дата рождения. Пользователь может не указать день рождения и тогда в поле нужно хранить NULL.
Добавьте 3 записи так, чтобы получалась таблица ниже:

**Ответ:**

``` sql
CREATE TABLE users (
id INT(10)UNSIGNED NOT NULL PRIMARY KEY,
first_name VARCHAR (50) NULL,
last_name VARCHAR (50) NULL,
birthday DATE NULL );
INSERT INTO users (id, first_name, last_name, birthday)
VALUES (1,'Дмитрий','Иванов',NULL),
(2,'Анатолий','Белый',NULL),
(3,'Денис','Давыдов','1995-09-08');
```

**Задание:**

Создайте таблицу orders с автоинкрементальным первичным ключом id, полем state для хранения статуса заказа и полем amount для хранения суммы заказа. Статус заказа умещается в строку длиной 8 символов, а сумма заказа является денежным типом до 1 млн. с двумя знаками после десятичной точки.

Добавьте 3 записи так, чтобы получалась таблица ниже:

**Ответ:**

``` sql
create table orders (
id int unsigned not null primary key auto_increment,
state varchar (8),
amount decimal (8,2)
);
insert into orders (state, amount)
values ('new', 1000.50),
('new', 3400.10),
('delivery', 7300.00)
```

[26.04.2025]

**Задание:**

Напишите тренировочный код для задания: Выберите из таблицы users всех пользователей с зарплатой от 40 000 рублей и выше. Данные нужно сначала отсортировать по убыванию зарплаты (salary), а затем в алфавитном порядке по имени (first_name). Не забудьте про удаление таблицы, если она существует (именно удаление). Код (ВЕСЬ) в одном файле.

**Ответ:**

``` sql
DROP TABLE IF EXISTS users;
CREATE TABLE users (
    id INT unsigned not null primary key auto_increment,
    first_name VARCHAR(50) NULL,
	last_name VARCHAR(50) NULL,
	birthday DATE NULL,
	salary MEDIUMINT UNSIGNED NULL,
	job ENUM('офис-менеджер', 'дизайнер', 'младший программист', 'водитель', 'фотограф', 'секретарь', 'ведущий программист', 'верстальщик')
);
INSERT INTO users (id, first_name, last_name, birthday, salary, job)
values (1, 'Дмитрий', 'Петров', '2000-03-14', 25000, 'офис-менеджер'),
(2, 'Ольга', 'Антонова', '1999-12-01', 41000, 'дизайнер'),
(3, 'Сергей', 'Васильев', '2002-02-20', 40000, 'младший программист'),
(4, 'Константин', 'Степаниденко', '2004-03-07', 30000, 'водитель'),
(5, 'Алена', 'Шикова', '1999-08-17', 53000, 'фотограф'),
(6, 'Василина', 'Парамонова', '2000-10-10', 28000, 'секретарь'),
(7, 'Александр', 'Пузаков', '2002-02-20', 120000, 'ведущий программист'),
(8, 'Алина', 'Антонова', '2002-01-01', 40000, 'верстальщик');
SELECT * FROM users WHERE salary >= 40000 ORDER BY salary desc, first_name asc\
```
